(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactSingletonHook = {}, global.React, global.ReactDOM));
})(this, (function (exports, React, reactDom) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  var SingleItemContainer = function SingleItemContainer(_ref) {
    var initValue = _ref.initValue,
        useHookBody = _ref.useHookBody,
        applyStateChange = _ref.applyStateChange;
    var lastState = React.useRef(initValue);

    if (typeof useHookBody !== 'function') {
      throw new Error("function expected as hook body parameter. got " + typeof useHookBody);
    }

    var val = useHookBody(); //useLayoutEffect is safe from SSR perspective because SingleItemContainer should never be rendered on server

    React.useLayoutEffect(function () {
      if (lastState.current !== val) {
        lastState.current = val;
        applyStateChange(val);
      }
    }, [applyStateChange, val]);
    return null;
  };

  var warning = function warning(message) {
    if (console && console.warn) {
      console.warn(message);
    }
  };

  // avoid direct usage of 'window' because `window is not defined` error might happen in babel-node

  var globalObject = typeof self === 'object' && self.self === self && self || typeof global === 'object' && global.global === global && global || this;
  var batch = function batch(cb) {
    return reactDom.unstable_batchedUpdates(cb);
  };
  var mount = function mount(C) {
    if (globalObject.document && globalObject.document.createElement) {
      reactDom.render( /*#__PURE__*/React__default["default"].createElement(C, null), globalObject.document.createElement('div'));
    } else {
      warning('Can not mount SingletonHooksContainer on server side. ' + 'Did you manage to run useEffect on server? ' + 'Please mount SingletonHooksContainer into your components tree manually.');
    }
  };

  var SingletonHooksContainerMounted = false;
  var SingletonHooksContainerRendered = false;
  var SingletonHooksContainerMountedAutomatically = false;
  var mountQueue = [];

  var mountIntoContainerDefault = function mountIntoContainerDefault(item) {
    mountQueue.push(item);
    return function () {
      throw new Error('Can not unmount container! It is like a bug in react-singleton-hook library, because of unmountIfNoConsumers: true'); // mountQueue = mountQueue.filter(i => i !== item);
    };
  };

  var mountIntoContainer = mountIntoContainerDefault;
  var SingletonHooksContainer = function SingletonHooksContainer() {
    SingletonHooksContainerRendered = true;
    React.useEffect(function () {
      if (SingletonHooksContainerMounted) {
        warning('SingletonHooksContainer is mounted second time. ' + 'You should mount SingletonHooksContainer before any other component and never unmount it.' + 'Alternatively, dont use SingletonHooksContainer it at all, we will handle that for you.');
      }

      SingletonHooksContainerMounted = true;
    }, []);

    var _useState = React.useState([]),
        hooks = _useState[0],
        setHooks = _useState[1];

    React.useEffect(function () {
      mountIntoContainer = function mountIntoContainer(item) {
        setHooks(function (hooks) {
          return [].concat(hooks, [item]);
        });
        return function () {
          setHooks(function (hooks) {
            return hooks.filter(function (i) {
              return i !== item;
            });
          });
        };
      };

      setHooks(mountQueue);
    }, []);
    return /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, hooks.map(function (h, i) {
      return /*#__PURE__*/React__default["default"].createElement(SingleItemContainer, _extends({}, h, {
        key: i
      }));
    }));
  };
  var addHook = function addHook(hook) {
    if (!SingletonHooksContainerRendered && !SingletonHooksContainerMountedAutomatically) {
      SingletonHooksContainerMountedAutomatically = true;
      mount(SingletonHooksContainer);
    }

    return mountIntoContainer(hook);
  };

  var singletonHook = function singletonHook(initValue, useHookBody, options) {
    if (options === void 0) {
      options = {};
    }

    var mounted = false;
    var removeHook = undefined;
    var initStateCalculated = false;
    var lastKnownState = undefined;
    var consumers = [];
    var _options = options,
        _options$unmountIfNoC = _options.unmountIfNoConsumers,
        unmountIfNoConsumers = _options$unmountIfNoC === void 0 ? false : _options$unmountIfNoC;

    var applyStateChange = function applyStateChange(newState) {
      lastKnownState = newState;
      batch(function () {
        return consumers.forEach(function (c) {
          return c(newState);
        });
      });
    };

    var stateInitializer = function stateInitializer() {
      if (!initStateCalculated) {
        lastKnownState = typeof initValue === 'function' ? initValue() : initValue;
        initStateCalculated = true;
      }

      return lastKnownState;
    };

    return function () {
      var _useState = React.useState(stateInitializer),
          state = _useState[0],
          setState = _useState[1];

      React.useEffect(function () {
        if (!mounted) {
          mounted = true;
          removeHook = addHook({
            initValue: initValue,
            useHookBody: useHookBody,
            applyStateChange: applyStateChange
          });
        }

        consumers.push(setState);

        if (lastKnownState !== state) {
          setState(lastKnownState);
        }

        return function () {
          consumers.splice(consumers.indexOf(setState), 1);

          if (consumers.length === 0 && unmountIfNoConsumers) {
            removeHook();
            mounted = false;
          }
        }; // eslint-disable-next-line react-hooks/exhaustive-deps
      }, []);
      return state;
    };
  };

  var ReactSingletonHook = {
    singletonHook: singletonHook,
    SingletonHooksContainer: SingletonHooksContainer
  };

  exports.SingletonHooksContainer = SingletonHooksContainer;
  exports["default"] = ReactSingletonHook;
  exports.singletonHook = singletonHook;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
